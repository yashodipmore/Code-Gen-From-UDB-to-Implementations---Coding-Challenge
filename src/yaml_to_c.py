#!/usr/bin/env python3
"""
RISC-V UDB YAML to C Header Converter

This program reads RISC-V Unified Database YAML instruction files and converts
them to C header files with structured data representation.
"""

import yaml
import sys
import os
import re
from typing import Dict, Any, List

def sanitize_c_identifier(name: str) -> str:
    """Convert a string to a valid C identifier."""
    # Replace non-alphanumeric characters with underscores
    sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    # Ensure it doesn't start with a digit
    if sanitized[0].isdigit():
        sanitized = '_' + sanitized
    return sanitized

def escape_c_string(text: str) -> str:
    """Escape a string for use in C string literals."""
    if text is None:
        return ""
    # Replace backslashes, quotes, newlines, and tabs
    text = text.replace('\\', '\\\\')
    text = text.replace('"', '\\"')
    text = text.replace('\n', '\\n')
    text = text.replace('\t', '\\t')
    text = text.replace('\r', '\\r')
    return text

def generate_encoding_variables(variables: List[Dict]) -> str:
    """Generate C structure for encoding variables."""
    if not variables:
        return "    /* No encoding variables */\n"
    
    result = ""
    for var in variables:
        name = sanitize_c_identifier(var['name'])
        location = var['location']
        result += f'    {{ "{var["name"]}", "{location}" }},\n'
    return result

def yaml_to_c_header(yaml_file: str, output_file: str) -> None:
    """Convert YAML instruction file to C header file."""
    
    # Read and parse YAML file
    try:
        with open(yaml_file, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
    except FileNotFoundError:
        print(f"Error: File '{yaml_file}' not found.")
        sys.exit(1)
    except yaml.YAMLError as e:
        print(f"Error parsing YAML file: {e}")
        sys.exit(1)
    
    # Extract instruction name for struct naming
    inst_name = sanitize_c_identifier(data.get('name', 'unknown'))
    
    # Generate C header content
    header_content = f"""/*
 * Generated C Header from RISC-V UDB YAML
 * Original file: {os.path.basename(yaml_file)}
 * Generated by: yaml_to_c.py
 */

#ifndef RISCV_INST_{inst_name.upper()}_H
#define RISCV_INST_{inst_name.upper()}_H

#include <stdint.h>

/* Encoding variable structure */
typedef struct {{
    const char* name;
    const char* location;
}} encoding_variable_t;

/* Access modes structure */
typedef struct {{
    const char* s;      /* Supervisor mode */
    const char* u;      /* User mode */
    const char* vs;     /* Virtual supervisor mode */
    const char* vu;     /* Virtual user mode */
}} access_modes_t;

/* Main instruction structure */
typedef struct {{
    const char* schema;
    const char* kind;
    const char* name;
    const char* long_name;
    const char* description;
    const char* defined_by;
    const char* assembly;
    
    /* Encoding information */
    const char* encoding_match;
    encoding_variable_t encoding_variables[16];  /* Max 16 variables */
    int num_variables;
    
    /* Access modes */
    access_modes_t access;
    
    /* Timing and operations */
    int data_independent_timing;
    const char* operation;
    const char* sail_operation;
}} riscv_instruction_t;

/* Global instruction data */
extern const riscv_instruction_t {inst_name}_instruction;

/* Instruction data definition */
const riscv_instruction_t {inst_name}_instruction = {{
    .schema = "{escape_c_string(data.get('$schema', ''))}",
    .kind = "{escape_c_string(data.get('kind', ''))}",
    .name = "{escape_c_string(data.get('name', ''))}",
    .long_name = "{escape_c_string(data.get('long_name', ''))}",
    .description = "{escape_c_string(data.get('description', ''))}",
    .defined_by = "{escape_c_string(data.get('definedBy', ''))}",
    .assembly = "{escape_c_string(data.get('assembly', ''))}",
    
    /* Encoding */
    .encoding_match = "{escape_c_string(data.get('encoding', {}).get('match', ''))}",
    .encoding_variables = {{
{generate_encoding_variables(data.get('encoding', {}).get('variables', []))}        {{ NULL, NULL }}  /* Sentinel */
    }},
    .num_variables = {len(data.get('encoding', {}).get('variables', []))},
    
    /* Access modes */
    .access = {{
        .s = "{escape_c_string(data.get('access', {}).get('s', ''))}",
        .u = "{escape_c_string(data.get('access', {}).get('u', ''))}",
        .vs = "{escape_c_string(data.get('access', {}).get('vs', ''))}",
        .vu = "{escape_c_string(data.get('access', {}).get('vu', ''))}",
    }},
    
    /* Timing and operations */
    .data_independent_timing = {1 if data.get('data_independent_timing', False) else 0},
    .operation = "{escape_c_string(data.get('operation()', ''))}",
    .sail_operation = "{escape_c_string(data.get('sail()', ''))}"
}};

#endif /* RISCV_INST_{inst_name.upper()}_H */
"""
    
    # Write C header file
    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(header_content)
        print(f"Successfully generated C header: {output_file}")
    except IOError as e:
        print(f"Error writing C header file: {e}")
        sys.exit(1)

def main():
    """Main function."""
    if len(sys.argv) != 3:
        print("Usage: python yaml_to_c.py <input.yaml> <output.h>")
        sys.exit(1)
    
    yaml_file = sys.argv[1]
    output_file = sys.argv[2]
    
    yaml_to_c_header(yaml_file, output_file)

if __name__ == "__main__":
    main()
