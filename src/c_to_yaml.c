/*
 * C to YAML Converter for RISC-V Instructions
 * 
 * This program reads a C header file generated by yaml_to_c.py and converts
 * the instruction data back to YAML format.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

/* Maximum line length for reading files */
#define MAX_LINE_LENGTH 1024
#define MAX_STRING_LENGTH 4096

/* Structure to hold parsed instruction data */
typedef struct {
    char schema[256];
    char kind[256];
    char name[256];
    char long_name[256];
    char description[MAX_STRING_LENGTH];
    char defined_by[256];
    char assembly[256];
    char encoding_match[256];
    
    /* Encoding variables */
    struct {
        char name[256];
        char location[256];
    } variables[16];
    int num_variables;
    
    /* Access modes */
    char access_s[256];
    char access_u[256];
    char access_vs[256];
    char access_vu[256];
    
    int data_independent_timing;
    char operation[MAX_STRING_LENGTH];
    char sail_operation[MAX_STRING_LENGTH];
} instruction_data_t;

/* Function to trim whitespace from a string */
char* trim(char* str) {
    char* end;
    
    /* Trim leading space */
    while(isspace((unsigned char)*str)) str++;
    
    if(*str == 0) return str;
    
    /* Trim trailing space */
    end = str + strlen(str) - 1;
    while(end > str && isspace((unsigned char)*end)) end--;
    
    end[1] = '\0';
    return str;
}

/* Function to extract string value from C string literal */
void extract_string_value(const char* line, const char* field, char* output, size_t output_size) {
    char search_pattern[256];
    snprintf(search_pattern, sizeof(search_pattern), ".%s = \"", field);
    
    char* start = strstr(line, search_pattern);
    if (!start) return;
    
    start += strlen(search_pattern);
    char* end = strstr(start, "\",");
    if (!end) {
        end = strstr(start, "\"");
        if (!end) return;
    }
    
    size_t len = end - start;
    if (len >= output_size) len = output_size - 1;
    
    strncpy(output, start, len);
    output[len] = '\0';
    
    /* Unescape common escape sequences */
    char* src = output;
    char* dst = output;
    while (*src) {
        if (*src == '\\' && *(src + 1)) {
            src++;
            switch (*src) {
                case 'n': *dst++ = '\n'; break;
                case 't': *dst++ = '\t'; break;
                case 'r': *dst++ = '\r'; break;
                case '\\': *dst++ = '\\'; break;
                case '"': *dst++ = '"'; break;
                default: *dst++ = *src; break;
            }
        } else {
            *dst++ = *src;
        }
        src++;
    }
    *dst = '\0';
}

/* Function to extract integer value */
int extract_int_value(const char* line, const char* field) {
    char search_pattern[256];
    snprintf(search_pattern, sizeof(search_pattern), ".%s = ", field);
    
    char* start = strstr(line, search_pattern);
    if (!start) return 0;
    
    start += strlen(search_pattern);
    return atoi(start);
}

/* Function to parse encoding variables from the header file */
void parse_encoding_variables(FILE* file, instruction_data_t* inst) {
    char line[MAX_LINE_LENGTH];
    int var_count = 0;
    
    while (fgets(line, sizeof(line), file) && var_count < 16) {
        trim(line);
        
        /* Look for variable entries */
        if (strstr(line, "{ \"") && strstr(line, "\", \"") && strstr(line, "\" },")) {
            char* name_start = strstr(line, "{ \"") + 3;
            char* name_end = strstr(name_start, "\", \"");
            if (name_end) {
                size_t name_len = name_end - name_start;
                if (name_len < sizeof(inst->variables[var_count].name)) {
                    strncpy(inst->variables[var_count].name, name_start, name_len);
                    inst->variables[var_count].name[name_len] = '\0';
                }
                
                char* loc_start = name_end + 4;
                char* loc_end = strstr(loc_start, "\" }");
                if (loc_end) {
                    size_t loc_len = loc_end - loc_start;
                    if (loc_len < sizeof(inst->variables[var_count].location)) {
                        strncpy(inst->variables[var_count].location, loc_start, loc_len);
                        inst->variables[var_count].location[loc_len] = '\0';
                    }
                    var_count++;
                }
            }
        }
        
        /* Stop when we hit the sentinel or end of variables array */
        if (strstr(line, "{ NULL, NULL }")) {
            break;
        }
    }
    
    inst->num_variables = var_count;
}

/* Function to parse the C header file */
int parse_header_file(const char* filename, instruction_data_t* inst) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        fprintf(stderr, "Error: Cannot open file %s\n", filename);
        return 0;
    }
    
    char line[MAX_LINE_LENGTH];
    
    /* Initialize structure */
    memset(inst, 0, sizeof(instruction_data_t));
    
    while (fgets(line, sizeof(line), file)) {
        trim(line);
        
        /* Parse simple string fields */
        extract_string_value(line, "schema", inst->schema, sizeof(inst->schema));
        extract_string_value(line, "kind", inst->kind, sizeof(inst->kind));
        extract_string_value(line, "name", inst->name, sizeof(inst->name));
        extract_string_value(line, "long_name", inst->long_name, sizeof(inst->long_name));
        extract_string_value(line, "description", inst->description, sizeof(inst->description));
        extract_string_value(line, "defined_by", inst->defined_by, sizeof(inst->defined_by));
        extract_string_value(line, "assembly", inst->assembly, sizeof(inst->assembly));
        extract_string_value(line, "encoding_match", inst->encoding_match, sizeof(inst->encoding_match));
        extract_string_value(line, "operation", inst->operation, sizeof(inst->operation));
        extract_string_value(line, "sail_operation", inst->sail_operation, sizeof(inst->sail_operation));
        
        /* Parse access mode fields */
        extract_string_value(line, "s", inst->access_s, sizeof(inst->access_s));
        extract_string_value(line, "u", inst->access_u, sizeof(inst->access_u));
        extract_string_value(line, "vs", inst->access_vs, sizeof(inst->access_vs));
        extract_string_value(line, "vu", inst->access_vu, sizeof(inst->access_vu));
        
        /* Parse integer fields */
        if (strstr(line, ".data_independent_timing = ")) {
            inst->data_independent_timing = extract_int_value(line, "data_independent_timing");
        }
        
        /* Parse encoding variables */
        if (strstr(line, ".encoding_variables = {")) {
            parse_encoding_variables(file, inst);
        }
    }
    
    fclose(file);
    return 1;
}

/* Function to output YAML format */
void output_yaml(const instruction_data_t* inst, const char* output_filename) {
    FILE* file;
    
    if (output_filename) {
        file = fopen(output_filename, "w");
        if (!file) {
            fprintf(stderr, "Error: Cannot create output file %s\n", output_filename);
            return;
        }
    } else {
        file = stdout;
    }
    
    /* Output YAML header */
    if (strlen(inst->schema) > 0) {
        fprintf(file, "$schema: \"%s\"\n", inst->schema);
    }
    if (strlen(inst->kind) > 0) {
        fprintf(file, "kind: %s\n", inst->kind);
    }
    if (strlen(inst->name) > 0) {
        fprintf(file, "name: %s\n", inst->name);
    }
    if (strlen(inst->long_name) > 0) {
        fprintf(file, "long_name: %s\n", inst->long_name);
    }
    
    /* Description with proper YAML multiline formatting */
    if (strlen(inst->description) > 0) {
        fprintf(file, "description: |\n");
        char* desc = strdup(inst->description);
        char* line = strtok(desc, "\n");
        while (line) {
            fprintf(file, "  %s\n", line);
            line = strtok(NULL, "\n");
        }
        free(desc);
    }
    
    if (strlen(inst->defined_by) > 0) {
        fprintf(file, "definedBy: %s\n", inst->defined_by);
    }
    if (strlen(inst->assembly) > 0) {
        fprintf(file, "assembly: %s\n", inst->assembly);
    }
    
    /* Encoding section */
    fprintf(file, "encoding:\n");
    if (strlen(inst->encoding_match) > 0) {
        fprintf(file, "  match: %s\n", inst->encoding_match);
    }
    
    if (inst->num_variables > 0) {
        fprintf(file, "  variables:\n");
        for (int i = 0; i < inst->num_variables; i++) {
            fprintf(file, "    - name: %s\n", inst->variables[i].name);
            fprintf(file, "      location: %s\n", inst->variables[i].location);
        }
    }
    
    /* Access section */
    fprintf(file, "access:\n");
    if (strlen(inst->access_s) > 0) {
        fprintf(file, "  s: %s\n", inst->access_s);
    }
    if (strlen(inst->access_u) > 0) {
        fprintf(file, "  u: %s\n", inst->access_u);
    }
    if (strlen(inst->access_vs) > 0) {
        fprintf(file, "  vs: %s\n", inst->access_vs);
    }
    if (strlen(inst->access_vu) > 0) {
        fprintf(file, "  vu: %s\n", inst->access_vu);
    }
    
    /* Data independent timing */
    fprintf(file, "data_independent_timing: %s\n", 
            inst->data_independent_timing ? "true" : "false");
    
    /* Operations */
    if (strlen(inst->operation) > 0) {
        fprintf(file, "operation(): |\n");
        char* op = strdup(inst->operation);
        char* line = strtok(op, "\n");
        while (line) {
            fprintf(file, "  %s\n", line);
            line = strtok(NULL, "\n");
        }
        free(op);
    }
    
    if (strlen(inst->sail_operation) > 0) {
        fprintf(file, "sail(): |\n");
        char* sail = strdup(inst->sail_operation);
        char* line = strtok(sail, "\n");
        while (line) {
            fprintf(file, "  %s\n", line);
            line = strtok(NULL, "\n");
        }
        free(sail);
    }
    
    if (output_filename) {
        fclose(file);
        printf("YAML output written to: %s\n", output_filename);
    }
}

int main(int argc, char* argv[]) {
    if (argc < 2 || argc > 3) {
        fprintf(stderr, "Usage: %s <header_file> [output_yaml_file]\n", argv[0]);
        fprintf(stderr, "If output_yaml_file is not specified, output goes to stdout\n");
        return 1;
    }
    
    instruction_data_t inst;
    
    if (!parse_header_file(argv[1], &inst)) {
        return 1;
    }
    
    const char* output_file = (argc == 3) ? argv[2] : NULL;
    output_yaml(&inst, output_file);
    
    return 0;
}
